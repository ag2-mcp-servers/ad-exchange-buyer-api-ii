# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T00:38:46+00:00

from __future__ import annotations

from enum import Enum
from typing import List, Optional

from pydantic import BaseModel, Field


class AcceptProposalRequest(BaseModel):
    proposalRevision: Optional[str] = Field(
        None, description='The last known client revision number of the proposal.'
    )


class SizeType(Enum):
    SIZE_TYPE_UNSPECIFIED = 'SIZE_TYPE_UNSPECIFIED'
    PIXEL = 'PIXEL'
    INTERSTITIAL = 'INTERSTITIAL'
    NATIVE = 'NATIVE'
    FLUID = 'FLUID'


class AdSize(BaseModel):
    height: Optional[str] = Field(
        None,
        description='The height of the ad slot in pixels. This field will be present only when size type is `PIXEL`.',
    )
    sizeType: Optional[SizeType] = Field(
        None, description='The size type of the ad slot.'
    )
    width: Optional[str] = Field(
        None,
        description='The width of the ad slot in pixels. This field will be present only when size type is `PIXEL`.',
    )


class AdTechnologyProviders(BaseModel):
    detectedProviderIds: Optional[List[str]] = Field(
        None,
        description='The detected ad technology provider IDs for this creative. See https://storage.googleapis.com/adx-rtb-dictionaries/providers.csv for mapping of provider ID to provided name, a privacy policy URL, and a list of domains which can be attributed to the provider. If the creative contains provider IDs that are outside of those listed in the `BidRequest.adslot.consented_providers_settings.consented_providers` field on the (Google bid protocol)[https://developers.google.com/authorized-buyers/rtb/downloads/realtime-bidding-proto] and the `BidRequest.user.ext.consented_providers_settings.consented_providers` field on the (OpenRTB protocol)[https://developers.google.com/authorized-buyers/rtb/downloads/openrtb-adx-proto], and a bid is submitted with that creative for an impression that will serve to an EEA user, the bid will be filtered before the auction.',
    )
    hasUnidentifiedProvider: Optional[bool] = Field(
        None,
        description='Whether the creative contains an unidentified ad technology provider. If true for a given creative, any bid submitted with that creative for an impression that will serve to an EEA user will be filtered before the auction.',
    )


class AppType(Enum):
    NATIVE = 'NATIVE'
    WEB = 'WEB'


class AppContext(BaseModel):
    appTypes: Optional[List[AppType]] = Field(
        None, description='The app types this restriction applies to.'
    )


class AuctionType(Enum):
    OPEN_AUCTION = 'OPEN_AUCTION'
    DIRECT_DEALS = 'DIRECT_DEALS'


class AuctionContext(BaseModel):
    auctionTypes: Optional[List[AuctionType]] = Field(
        None, description='The auction types this restriction applies to.'
    )


class Status(Enum):
    STATUS_UNSPECIFIED = 'STATUS_UNSPECIFIED'
    RESPONSES_WITHOUT_BIDS = 'RESPONSES_WITHOUT_BIDS'
    RESPONSES_WITHOUT_BIDS_FOR_ACCOUNT = 'RESPONSES_WITHOUT_BIDS_FOR_ACCOUNT'
    RESPONSES_WITHOUT_BIDS_FOR_DEAL = 'RESPONSES_WITHOUT_BIDS_FOR_DEAL'


class Buyer(BaseModel):
    accountId: Optional[str] = Field(
        None, description='Authorized Buyers account ID of the buyer.'
    )


class CancelNegotiationRequest(BaseModel):
    pass


class EntityType(Enum):
    ENTITY_TYPE_UNSPECIFIED = 'ENTITY_TYPE_UNSPECIFIED'
    ADVERTISER = 'ADVERTISER'
    BRAND = 'BRAND'
    AGENCY = 'AGENCY'
    ENTITY_TYPE_UNCLASSIFIED = 'ENTITY_TYPE_UNCLASSIFIED'


class Role(Enum):
    CLIENT_ROLE_UNSPECIFIED = 'CLIENT_ROLE_UNSPECIFIED'
    CLIENT_DEAL_VIEWER = 'CLIENT_DEAL_VIEWER'
    CLIENT_DEAL_NEGOTIATOR = 'CLIENT_DEAL_NEGOTIATOR'
    CLIENT_DEAL_APPROVER = 'CLIENT_DEAL_APPROVER'


class Status1(Enum):
    CLIENT_STATUS_UNSPECIFIED = 'CLIENT_STATUS_UNSPECIFIED'
    DISABLED = 'DISABLED'
    ACTIVE = 'ACTIVE'


class Client(BaseModel):
    clientAccountId: Optional[str] = Field(
        None,
        description='The globally-unique numerical ID of the client. The value of this field is ignored in create and update operations.',
    )
    clientName: Optional[str] = Field(
        None,
        description='Name used to represent this client to publishers. You may have multiple clients that map to the same entity, but for each client the combination of `clientName` and entity must be unique. You can specify this field as empty. Maximum length of 255 characters is allowed.',
    )
    entityId: Optional[str] = Field(
        None,
        description='Numerical identifier of the client entity. The entity can be an advertiser, a brand, or an agency. This identifier is unique among all the entities with the same type. The value of this field is ignored if the entity type is not provided. A list of all known advertisers with their identifiers is available in the [advertisers.txt](https://storage.googleapis.com/adx-rtb-dictionaries/advertisers.txt) file. A list of all known brands with their identifiers is available in the [brands.txt](https://storage.googleapis.com/adx-rtb-dictionaries/brands.txt) file. A list of all known agencies with their identifiers is available in the [agencies.txt](https://storage.googleapis.com/adx-rtb-dictionaries/agencies.txt) file.',
    )
    entityName: Optional[str] = Field(
        None,
        description='The name of the entity. This field is automatically fetched based on the type and ID. The value of this field is ignored in create and update operations.',
    )
    entityType: Optional[EntityType] = Field(
        None,
        description='An optional field for specifying the type of the client entity: `ADVERTISER`, `BRAND`, or `AGENCY`.',
    )
    partnerClientId: Optional[str] = Field(
        None,
        description='Optional arbitrary unique identifier of this client buyer from the standpoint of its Ad Exchange sponsor buyer. This field can be used to associate a client buyer with the identifier in the namespace of its sponsor buyer, lookup client buyers by that identifier and verify whether an Ad Exchange counterpart of a given client buyer already exists. If present, must be unique among all the client buyers for its Ad Exchange sponsor buyer.',
    )
    role: Optional[Role] = Field(
        None,
        description='The role which is assigned to the client buyer. Each role implies a set of permissions granted to the client. Must be one of `CLIENT_DEAL_VIEWER`, `CLIENT_DEAL_NEGOTIATOR` or `CLIENT_DEAL_APPROVER`.',
    )
    status: Optional[Status1] = Field(
        None, description='The status of the client buyer.'
    )
    visibleToSeller: Optional[bool] = Field(
        None, description='Whether the client buyer will be visible to sellers.'
    )


class Status2(Enum):
    USER_STATUS_UNSPECIFIED = 'USER_STATUS_UNSPECIFIED'
    PENDING = 'PENDING'
    ACTIVE = 'ACTIVE'
    DISABLED = 'DISABLED'


class ClientUser(BaseModel):
    clientAccountId: Optional[str] = Field(
        None,
        description='Numerical account ID of the client buyer with which the user is associated; the buyer must be a client of the current sponsor buyer. The value of this field is ignored in an update operation.',
    )
    email: Optional[str] = Field(
        None,
        description="User's email address. The value of this field is ignored in an update operation.",
    )
    status: Optional[Status2] = Field(
        None, description='The status of the client user.'
    )
    userId: Optional[str] = Field(
        None,
        description='The unique numerical ID of the client user that has accepted an invitation. The value of this field is ignored in an update operation.',
    )


class ClientUserInvitation(BaseModel):
    clientAccountId: Optional[str] = Field(
        None,
        description='Numerical account ID of the client buyer that the invited user is associated with. The value of this field is ignored in create operations.',
    )
    email: Optional[str] = Field(
        None,
        description='The email address to which the invitation is sent. Email addresses should be unique among all client users under each sponsor buyer.',
    )
    invitationId: Optional[str] = Field(
        None,
        description='The unique numerical ID of the invitation that is sent to the user. The value of this field is ignored in create operations.',
    )


class CompleteSetupRequest(BaseModel):
    pass


class ContactInformation(BaseModel):
    email: Optional[str] = Field(None, description='Email address for the contact.')
    name: Optional[str] = Field(None, description='The name of the contact.')


class Type(Enum):
    CORRECTION_TYPE_UNSPECIFIED = 'CORRECTION_TYPE_UNSPECIFIED'
    VENDOR_IDS_ADDED = 'VENDOR_IDS_ADDED'
    SSL_ATTRIBUTE_REMOVED = 'SSL_ATTRIBUTE_REMOVED'
    FLASH_FREE_ATTRIBUTE_REMOVED = 'FLASH_FREE_ATTRIBUTE_REMOVED'
    FLASH_FREE_ATTRIBUTE_ADDED = 'FLASH_FREE_ATTRIBUTE_ADDED'
    REQUIRED_ATTRIBUTE_ADDED = 'REQUIRED_ATTRIBUTE_ADDED'
    REQUIRED_VENDOR_ADDED = 'REQUIRED_VENDOR_ADDED'
    SSL_ATTRIBUTE_ADDED = 'SSL_ATTRIBUTE_ADDED'
    IN_BANNER_VIDEO_ATTRIBUTE_ADDED = 'IN_BANNER_VIDEO_ATTRIBUTE_ADDED'
    MRAID_ATTRIBUTE_ADDED = 'MRAID_ATTRIBUTE_ADDED'
    FLASH_ATTRIBUTE_REMOVED = 'FLASH_ATTRIBUTE_REMOVED'
    VIDEO_IN_SNIPPET_ATTRIBUTE_ADDED = 'VIDEO_IN_SNIPPET_ATTRIBUTE_ADDED'


class Attribute(Enum):
    ATTRIBUTE_UNSPECIFIED = 'ATTRIBUTE_UNSPECIFIED'
    IMAGE_RICH_MEDIA = 'IMAGE_RICH_MEDIA'
    ADOBE_FLASH_FLV = 'ADOBE_FLASH_FLV'
    IS_TAGGED = 'IS_TAGGED'
    IS_COOKIE_TARGETED = 'IS_COOKIE_TARGETED'
    IS_USER_INTEREST_TARGETED = 'IS_USER_INTEREST_TARGETED'
    EXPANDING_DIRECTION_NONE = 'EXPANDING_DIRECTION_NONE'
    EXPANDING_DIRECTION_UP = 'EXPANDING_DIRECTION_UP'
    EXPANDING_DIRECTION_DOWN = 'EXPANDING_DIRECTION_DOWN'
    EXPANDING_DIRECTION_LEFT = 'EXPANDING_DIRECTION_LEFT'
    EXPANDING_DIRECTION_RIGHT = 'EXPANDING_DIRECTION_RIGHT'
    EXPANDING_DIRECTION_UP_LEFT = 'EXPANDING_DIRECTION_UP_LEFT'
    EXPANDING_DIRECTION_UP_RIGHT = 'EXPANDING_DIRECTION_UP_RIGHT'
    EXPANDING_DIRECTION_DOWN_LEFT = 'EXPANDING_DIRECTION_DOWN_LEFT'
    EXPANDING_DIRECTION_DOWN_RIGHT = 'EXPANDING_DIRECTION_DOWN_RIGHT'
    CREATIVE_TYPE_HTML = 'CREATIVE_TYPE_HTML'
    CREATIVE_TYPE_VAST_VIDEO = 'CREATIVE_TYPE_VAST_VIDEO'
    EXPANDING_DIRECTION_UP_OR_DOWN = 'EXPANDING_DIRECTION_UP_OR_DOWN'
    EXPANDING_DIRECTION_LEFT_OR_RIGHT = 'EXPANDING_DIRECTION_LEFT_OR_RIGHT'
    EXPANDING_DIRECTION_ANY_DIAGONAL = 'EXPANDING_DIRECTION_ANY_DIAGONAL'
    EXPANDING_ACTION_ROLLOVER_TO_EXPAND = 'EXPANDING_ACTION_ROLLOVER_TO_EXPAND'
    INSTREAM_VAST_VIDEO_TYPE_VPAID_FLASH = 'INSTREAM_VAST_VIDEO_TYPE_VPAID_FLASH'
    RICH_MEDIA_CAPABILITY_TYPE_MRAID = 'RICH_MEDIA_CAPABILITY_TYPE_MRAID'
    RICH_MEDIA_CAPABILITY_TYPE_FLASH = 'RICH_MEDIA_CAPABILITY_TYPE_FLASH'
    RICH_MEDIA_CAPABILITY_TYPE_HTML5 = 'RICH_MEDIA_CAPABILITY_TYPE_HTML5'
    SKIPPABLE_INSTREAM_VIDEO = 'SKIPPABLE_INSTREAM_VIDEO'
    RICH_MEDIA_CAPABILITY_TYPE_SSL = 'RICH_MEDIA_CAPABILITY_TYPE_SSL'
    RICH_MEDIA_CAPABILITY_TYPE_NON_SSL = 'RICH_MEDIA_CAPABILITY_TYPE_NON_SSL'
    RICH_MEDIA_CAPABILITY_TYPE_INTERSTITIAL = 'RICH_MEDIA_CAPABILITY_TYPE_INTERSTITIAL'
    NON_SKIPPABLE_INSTREAM_VIDEO = 'NON_SKIPPABLE_INSTREAM_VIDEO'
    NATIVE_ELIGIBILITY_ELIGIBLE = 'NATIVE_ELIGIBILITY_ELIGIBLE'
    NON_VPAID = 'NON_VPAID'
    NATIVE_ELIGIBILITY_NOT_ELIGIBLE = 'NATIVE_ELIGIBILITY_NOT_ELIGIBLE'
    ANY_INTERSTITIAL = 'ANY_INTERSTITIAL'
    NON_INTERSTITIAL = 'NON_INTERSTITIAL'
    IN_BANNER_VIDEO = 'IN_BANNER_VIDEO'
    RENDERING_SIZELESS_ADX = 'RENDERING_SIZELESS_ADX'
    OMSDK_1_0 = 'OMSDK_1_0'


class DealsStatus(Enum):
    STATUS_UNSPECIFIED = 'STATUS_UNSPECIFIED'
    NOT_CHECKED = 'NOT_CHECKED'
    CONDITIONALLY_APPROVED = 'CONDITIONALLY_APPROVED'
    APPROVED = 'APPROVED'
    DISAPPROVED = 'DISAPPROVED'
    PENDING_REVIEW = 'PENDING_REVIEW'
    STATUS_TYPE_UNSPECIFIED = 'STATUS_TYPE_UNSPECIFIED'


class OpenAuctionStatus(Enum):
    STATUS_UNSPECIFIED = 'STATUS_UNSPECIFIED'
    NOT_CHECKED = 'NOT_CHECKED'
    CONDITIONALLY_APPROVED = 'CONDITIONALLY_APPROVED'
    APPROVED = 'APPROVED'
    DISAPPROVED = 'DISAPPROVED'
    PENDING_REVIEW = 'PENDING_REVIEW'
    STATUS_TYPE_UNSPECIFIED = 'STATUS_TYPE_UNSPECIFIED'


class RestrictedCategory(Enum):
    NO_RESTRICTED_CATEGORIES = 'NO_RESTRICTED_CATEGORIES'
    ALCOHOL = 'ALCOHOL'


class CreativeDealAssociation(BaseModel):
    accountId: Optional[str] = Field(
        None, description='The account the creative belongs to.'
    )
    creativeId: Optional[str] = Field(
        None, description='The ID of the creative associated with the deal.'
    )
    dealsId: Optional[str] = Field(
        None,
        description='The externalDealId for the deal associated with the creative.',
    )


class CreativeFormat(Enum):
    CREATIVE_FORMAT_UNSPECIFIED = 'CREATIVE_FORMAT_UNSPECIFIED'
    DISPLAY = 'DISPLAY'
    VIDEO = 'VIDEO'


class SkippableAdType(Enum):
    SKIPPABLE_AD_TYPE_UNSPECIFIED = 'SKIPPABLE_AD_TYPE_UNSPECIFIED'
    SKIPPABLE = 'SKIPPABLE'
    INSTREAM_SELECT = 'INSTREAM_SELECT'
    NOT_SKIPPABLE = 'NOT_SKIPPABLE'


class AllowedFormat(Enum):
    UNKNOWN = 'UNKNOWN'
    AUDIO = 'AUDIO'


class CreativeSizeType(Enum):
    CREATIVE_SIZE_TYPE_UNSPECIFIED = 'CREATIVE_SIZE_TYPE_UNSPECIFIED'
    REGULAR = 'REGULAR'
    INTERSTITIAL = 'INTERSTITIAL'
    VIDEO = 'VIDEO'
    NATIVE = 'NATIVE'


class NativeTemplate(Enum):
    UNKNOWN_NATIVE_TEMPLATE = 'UNKNOWN_NATIVE_TEMPLATE'
    NATIVE_CONTENT_AD = 'NATIVE_CONTENT_AD'
    NATIVE_APP_INSTALL_AD = 'NATIVE_APP_INSTALL_AD'
    NATIVE_VIDEO_CONTENT_AD = 'NATIVE_VIDEO_CONTENT_AD'
    NATIVE_VIDEO_APP_INSTALL_AD = 'NATIVE_VIDEO_APP_INSTALL_AD'


class SkippableAdType1(Enum):
    SKIPPABLE_AD_TYPE_UNSPECIFIED = 'SKIPPABLE_AD_TYPE_UNSPECIFIED'
    GENERIC = 'GENERIC'
    INSTREAM_SELECT = 'INSTREAM_SELECT'
    NOT_SKIPPABLE = 'NOT_SKIPPABLE'


class CreativeSpecification(BaseModel):
    creativeCompanionSizes: Optional[List[AdSize]] = Field(
        None,
        description='Companion sizes may be filled in only when this is a video creative.',
    )
    creativeSize: Optional[AdSize] = Field(
        None, description='The size of the creative.'
    )


class CriteriaTargeting(BaseModel):
    excludedCriteriaIds: Optional[List[str]] = Field(
        None, description='A list of numeric IDs to be excluded.'
    )
    targetedCriteriaIds: Optional[List[str]] = Field(
        None, description='A list of numeric IDs to be included.'
    )


class Date(BaseModel):
    day: Optional[int] = Field(
        None,
        description="Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.",
    )
    month: Optional[int] = Field(
        None,
        description='Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.',
    )
    year: Optional[int] = Field(
        None,
        description='Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.',
    )


class DayOfWeek(Enum):
    DAY_OF_WEEK_UNSPECIFIED = 'DAY_OF_WEEK_UNSPECIFIED'
    MONDAY = 'MONDAY'
    TUESDAY = 'TUESDAY'
    WEDNESDAY = 'WEDNESDAY'
    THURSDAY = 'THURSDAY'
    FRIDAY = 'FRIDAY'
    SATURDAY = 'SATURDAY'
    SUNDAY = 'SUNDAY'


class TimeZoneType(Enum):
    TIME_ZONE_SOURCE_UNSPECIFIED = 'TIME_ZONE_SOURCE_UNSPECIFIED'
    PUBLISHER = 'PUBLISHER'
    USER = 'USER'


class CreativePreApprovalPolicy(Enum):
    CREATIVE_PRE_APPROVAL_POLICY_UNSPECIFIED = (
        'CREATIVE_PRE_APPROVAL_POLICY_UNSPECIFIED'
    )
    SELLER_PRE_APPROVAL_REQUIRED = 'SELLER_PRE_APPROVAL_REQUIRED'
    SELLER_PRE_APPROVAL_NOT_REQUIRED = 'SELLER_PRE_APPROVAL_NOT_REQUIRED'


class CreativeSafeFrameCompatibility(Enum):
    CREATIVE_SAFE_FRAME_COMPATIBILITY_UNSPECIFIED = (
        'CREATIVE_SAFE_FRAME_COMPATIBILITY_UNSPECIFIED'
    )
    COMPATIBLE = 'COMPATIBLE'
    INCOMPATIBLE = 'INCOMPATIBLE'


class ProgrammaticCreativeSource(Enum):
    PROGRAMMATIC_CREATIVE_SOURCE_UNSPECIFIED = (
        'PROGRAMMATIC_CREATIVE_SOURCE_UNSPECIFIED'
    )
    ADVERTISER = 'ADVERTISER'
    PUBLISHER = 'PUBLISHER'


class SyndicationProduct(Enum):
    SYNDICATION_PRODUCT_UNSPECIFIED = 'SYNDICATION_PRODUCT_UNSPECIFIED'
    CONTENT = 'CONTENT'
    MOBILE = 'MOBILE'
    VIDEO = 'VIDEO'
    GAMES = 'GAMES'


class FirstPausedBy(Enum):
    BUYER_SELLER_ROLE_UNSPECIFIED = 'BUYER_SELLER_ROLE_UNSPECIFIED'
    BUYER = 'BUYER'
    SELLER = 'SELLER'


class DealPauseStatus(BaseModel):
    buyerPauseReason: Optional[str] = Field(
        None,
        description="The buyer's reason for pausing, if the buyer paused the deal.",
    )
    firstPausedBy: Optional[FirstPausedBy] = Field(
        None, description='The role of the person who first paused this deal.'
    )
    hasBuyerPaused: Optional[bool] = Field(
        None, description='True, if the buyer has paused the deal unilaterally.'
    )
    hasSellerPaused: Optional[bool] = Field(
        None, description='True, if the seller has paused the deal unilaterally.'
    )
    sellerPauseReason: Optional[str] = Field(
        None,
        description="The seller's reason for pausing, if the seller paused the deal.",
    )


class DealServingMetadata(BaseModel):
    dealPauseStatus: Optional[DealPauseStatus] = Field(
        None,
        description='Output only. Tracks which parties (if any) have paused a deal.',
    )


class BrandingType(Enum):
    BRANDING_TYPE_UNSPECIFIED = 'BRANDING_TYPE_UNSPECIFIED'
    BRANDED = 'BRANDED'
    SEMI_TRANSPARENT = 'SEMI_TRANSPARENT'


class CreativeBlockingLevel(Enum):
    CREATIVE_BLOCKING_LEVEL_UNSPECIFIED = 'CREATIVE_BLOCKING_LEVEL_UNSPECIFIED'
    PUBLISHER_BLOCKING_RULES = 'PUBLISHER_BLOCKING_RULES'
    ADX_POLICY_BLOCKING_ONLY = 'ADX_POLICY_BLOCKING_ONLY'


class DeliveryRateType(Enum):
    DELIVERY_RATE_TYPE_UNSPECIFIED = 'DELIVERY_RATE_TYPE_UNSPECIFIED'
    EVENLY = 'EVENLY'
    FRONT_LOADED = 'FRONT_LOADED'
    AS_FAST_AS_POSSIBLE = 'AS_FAST_AS_POSSIBLE'


class Reason(Enum):
    LENGTH_OF_IMAGE_ANIMATION = 'LENGTH_OF_IMAGE_ANIMATION'
    BROKEN_URL = 'BROKEN_URL'
    MEDIA_NOT_FUNCTIONAL = 'MEDIA_NOT_FUNCTIONAL'
    INVALID_FOURTH_PARTY_CALL = 'INVALID_FOURTH_PARTY_CALL'
    INCORRECT_REMARKETING_DECLARATION = 'INCORRECT_REMARKETING_DECLARATION'
    LANDING_PAGE_ERROR = 'LANDING_PAGE_ERROR'
    AD_SIZE_DOES_NOT_MATCH_AD_SLOT = 'AD_SIZE_DOES_NOT_MATCH_AD_SLOT'
    NO_BORDER = 'NO_BORDER'
    FOURTH_PARTY_BROWSER_COOKIES = 'FOURTH_PARTY_BROWSER_COOKIES'
    LSO_OBJECTS = 'LSO_OBJECTS'
    BLANK_CREATIVE = 'BLANK_CREATIVE'
    DESTINATION_URLS_UNDECLARED = 'DESTINATION_URLS_UNDECLARED'
    PROBLEM_WITH_CLICK_MACRO = 'PROBLEM_WITH_CLICK_MACRO'
    INCORRECT_AD_TECHNOLOGY_DECLARATION = 'INCORRECT_AD_TECHNOLOGY_DECLARATION'
    INCORRECT_DESTINATION_URL_DECLARATION = 'INCORRECT_DESTINATION_URL_DECLARATION'
    EXPANDABLE_INCORRECT_DIRECTION = 'EXPANDABLE_INCORRECT_DIRECTION'
    EXPANDABLE_DIRECTION_NOT_SUPPORTED = 'EXPANDABLE_DIRECTION_NOT_SUPPORTED'
    EXPANDABLE_INVALID_VENDOR = 'EXPANDABLE_INVALID_VENDOR'
    EXPANDABLE_FUNCTIONALITY = 'EXPANDABLE_FUNCTIONALITY'
    VIDEO_INVALID_VENDOR = 'VIDEO_INVALID_VENDOR'
    VIDEO_UNSUPPORTED_LENGTH = 'VIDEO_UNSUPPORTED_LENGTH'
    VIDEO_UNSUPPORTED_FORMAT = 'VIDEO_UNSUPPORTED_FORMAT'
    VIDEO_FUNCTIONALITY = 'VIDEO_FUNCTIONALITY'
    LANDING_PAGE_DISABLED = 'LANDING_PAGE_DISABLED'
    MALWARE_SUSPECTED = 'MALWARE_SUSPECTED'
    ADULT_IMAGE_OR_VIDEO = 'ADULT_IMAGE_OR_VIDEO'
    INACCURATE_AD_TEXT = 'INACCURATE_AD_TEXT'
    COUNTERFEIT_DESIGNER_GOODS = 'COUNTERFEIT_DESIGNER_GOODS'
    POP_UP = 'POP_UP'
    INVALID_RTB_PROTOCOL_USAGE = 'INVALID_RTB_PROTOCOL_USAGE'
    RAW_IP_ADDRESS_IN_SNIPPET = 'RAW_IP_ADDRESS_IN_SNIPPET'
    UNACCEPTABLE_CONTENT_SOFTWARE = 'UNACCEPTABLE_CONTENT_SOFTWARE'
    UNAUTHORIZED_COOKIE_ON_GOOGLE_DOMAIN = 'UNAUTHORIZED_COOKIE_ON_GOOGLE_DOMAIN'
    UNDECLARED_FLASH_OBJECTS = 'UNDECLARED_FLASH_OBJECTS'
    INVALID_SSL_DECLARATION = 'INVALID_SSL_DECLARATION'
    DIRECT_DOWNLOAD_IN_AD = 'DIRECT_DOWNLOAD_IN_AD'
    MAXIMUM_DOWNLOAD_SIZE_EXCEEDED = 'MAXIMUM_DOWNLOAD_SIZE_EXCEEDED'
    DESTINATION_URL_SITE_NOT_CRAWLABLE = 'DESTINATION_URL_SITE_NOT_CRAWLABLE'
    BAD_URL_LEGAL_DISAPPROVAL = 'BAD_URL_LEGAL_DISAPPROVAL'
    PHARMA_GAMBLING_ALCOHOL_NOT_ALLOWED = 'PHARMA_GAMBLING_ALCOHOL_NOT_ALLOWED'
    DYNAMIC_DNS_AT_DESTINATION_URL = 'DYNAMIC_DNS_AT_DESTINATION_URL'
    POOR_IMAGE_OR_VIDEO_QUALITY = 'POOR_IMAGE_OR_VIDEO_QUALITY'
    UNACCEPTABLE_IMAGE_CONTENT = 'UNACCEPTABLE_IMAGE_CONTENT'
    INCORRECT_IMAGE_LAYOUT = 'INCORRECT_IMAGE_LAYOUT'
    IRRELEVANT_IMAGE_OR_VIDEO = 'IRRELEVANT_IMAGE_OR_VIDEO'
    DESTINATION_SITE_DOES_NOT_ALLOW_GOING_BACK = (
        'DESTINATION_SITE_DOES_NOT_ALLOW_GOING_BACK'
    )
    MISLEADING_CLAIMS_IN_AD = 'MISLEADING_CLAIMS_IN_AD'
    RESTRICTED_PRODUCTS = 'RESTRICTED_PRODUCTS'
    UNACCEPTABLE_CONTENT = 'UNACCEPTABLE_CONTENT'
    AUTOMATED_AD_CLICKING = 'AUTOMATED_AD_CLICKING'
    INVALID_URL_PROTOCOL = 'INVALID_URL_PROTOCOL'
    UNDECLARED_RESTRICTED_CONTENT = 'UNDECLARED_RESTRICTED_CONTENT'
    INVALID_REMARKETING_LIST_USAGE = 'INVALID_REMARKETING_LIST_USAGE'
    DESTINATION_SITE_NOT_CRAWLABLE_ROBOTS_TXT = (
        'DESTINATION_SITE_NOT_CRAWLABLE_ROBOTS_TXT'
    )
    CLICK_TO_DOWNLOAD_NOT_AN_APP = 'CLICK_TO_DOWNLOAD_NOT_AN_APP'
    INACCURATE_REVIEW_EXTENSION = 'INACCURATE_REVIEW_EXTENSION'
    SEXUALLY_EXPLICIT_CONTENT = 'SEXUALLY_EXPLICIT_CONTENT'
    GAINING_AN_UNFAIR_ADVANTAGE = 'GAINING_AN_UNFAIR_ADVANTAGE'
    GAMING_THE_GOOGLE_NETWORK = 'GAMING_THE_GOOGLE_NETWORK'
    DANGEROUS_PRODUCTS_KNIVES = 'DANGEROUS_PRODUCTS_KNIVES'
    DANGEROUS_PRODUCTS_EXPLOSIVES = 'DANGEROUS_PRODUCTS_EXPLOSIVES'
    DANGEROUS_PRODUCTS_GUNS = 'DANGEROUS_PRODUCTS_GUNS'
    DANGEROUS_PRODUCTS_DRUGS = 'DANGEROUS_PRODUCTS_DRUGS'
    DANGEROUS_PRODUCTS_TOBACCO = 'DANGEROUS_PRODUCTS_TOBACCO'
    DANGEROUS_PRODUCTS_WEAPONS = 'DANGEROUS_PRODUCTS_WEAPONS'
    UNCLEAR_OR_IRRELEVANT_AD = 'UNCLEAR_OR_IRRELEVANT_AD'
    PROFESSIONAL_STANDARDS = 'PROFESSIONAL_STANDARDS'
    DYSFUNCTIONAL_PROMOTION = 'DYSFUNCTIONAL_PROMOTION'
    INVALID_INTEREST_BASED_AD = 'INVALID_INTEREST_BASED_AD'
    MISUSE_OF_PERSONAL_INFORMATION = 'MISUSE_OF_PERSONAL_INFORMATION'
    OMISSION_OF_RELEVANT_INFORMATION = 'OMISSION_OF_RELEVANT_INFORMATION'
    UNAVAILABLE_PROMOTIONS = 'UNAVAILABLE_PROMOTIONS'
    MISLEADING_PROMOTIONS = 'MISLEADING_PROMOTIONS'
    INAPPROPRIATE_CONTENT = 'INAPPROPRIATE_CONTENT'
    SENSITIVE_EVENTS = 'SENSITIVE_EVENTS'
    SHOCKING_CONTENT = 'SHOCKING_CONTENT'
    ENABLING_DISHONEST_BEHAVIOR = 'ENABLING_DISHONEST_BEHAVIOR'
    TECHNICAL_REQUIREMENTS = 'TECHNICAL_REQUIREMENTS'
    RESTRICTED_POLITICAL_CONTENT = 'RESTRICTED_POLITICAL_CONTENT'
    UNSUPPORTED_CONTENT = 'UNSUPPORTED_CONTENT'
    INVALID_BIDDING_METHOD = 'INVALID_BIDDING_METHOD'
    VIDEO_TOO_LONG = 'VIDEO_TOO_LONG'
    VIOLATES_JAPANESE_PHARMACY_LAW = 'VIOLATES_JAPANESE_PHARMACY_LAW'
    UNACCREDITED_PET_PHARMACY = 'UNACCREDITED_PET_PHARMACY'
    ABORTION = 'ABORTION'
    CONTRACEPTIVES = 'CONTRACEPTIVES'
    NEED_CERTIFICATES_TO_ADVERTISE_IN_CHINA = 'NEED_CERTIFICATES_TO_ADVERTISE_IN_CHINA'
    KCDSP_REGISTRATION = 'KCDSP_REGISTRATION'
    NOT_FAMILY_SAFE = 'NOT_FAMILY_SAFE'
    CLINICAL_TRIAL_RECRUITMENT = 'CLINICAL_TRIAL_RECRUITMENT'
    MAXIMUM_NUMBER_OF_HTTP_CALLS_EXCEEDED = 'MAXIMUM_NUMBER_OF_HTTP_CALLS_EXCEEDED'
    MAXIMUM_NUMBER_OF_COOKIES_EXCEEDED = 'MAXIMUM_NUMBER_OF_COOKIES_EXCEEDED'
    PERSONAL_LOANS = 'PERSONAL_LOANS'
    UNSUPPORTED_FLASH_CONTENT = 'UNSUPPORTED_FLASH_CONTENT'
    MISUSE_BY_OMID_SCRIPT = 'MISUSE_BY_OMID_SCRIPT'
    NON_WHITELISTED_OMID_VENDOR = 'NON_WHITELISTED_OMID_VENDOR'
    DESTINATION_EXPERIENCE = 'DESTINATION_EXPERIENCE'
    UNSUPPORTED_LANGUAGE = 'UNSUPPORTED_LANGUAGE'
    NON_SSL_COMPLIANT = 'NON_SSL_COMPLIANT'
    TEMPORARY_PAUSE = 'TEMPORARY_PAUSE'
    BAIL_BONDS = 'BAIL_BONDS'
    EXPERIMENTAL_MEDICAL_TREATMENT = 'EXPERIMENTAL_MEDICAL_TREATMENT'


class Disapproval(BaseModel):
    details: Optional[List[str]] = Field(
        None, description='Additional details about the reason for disapproval.'
    )
    reason: Optional[Reason] = Field(
        None, description='The categorized reason for disapproval.'
    )


class Empty(BaseModel):
    pass


class BreakdownDimension(Enum):
    BREAKDOWN_DIMENSION_UNSPECIFIED = 'BREAKDOWN_DIMENSION_UNSPECIFIED'
    PUBLISHER_IDENTIFIER = 'PUBLISHER_IDENTIFIER'


class Environment(Enum):
    ENVIRONMENT_UNSPECIFIED = 'ENVIRONMENT_UNSPECIFIED'
    WEB = 'WEB'
    APP = 'APP'


class Format(Enum):
    FORMAT_UNSPECIFIED = 'FORMAT_UNSPECIFIED'
    NATIVE_DISPLAY = 'NATIVE_DISPLAY'
    NATIVE_VIDEO = 'NATIVE_VIDEO'
    NON_NATIVE_DISPLAY = 'NON_NATIVE_DISPLAY'
    NON_NATIVE_VIDEO = 'NON_NATIVE_VIDEO'


class Platform(Enum):
    PLATFORM_UNSPECIFIED = 'PLATFORM_UNSPECIFIED'
    DESKTOP = 'DESKTOP'
    TABLET = 'TABLET'
    MOBILE = 'MOBILE'


class TimeSeriesGranularity(Enum):
    TIME_SERIES_GRANULARITY_UNSPECIFIED = 'TIME_SERIES_GRANULARITY_UNSPECIFIED'
    HOURLY = 'HOURLY'
    DAILY = 'DAILY'


class FirstPartyMobileApplicationTargeting(BaseModel):
    excludedAppIds: Optional[List[str]] = Field(
        None, description='A list of application IDs to be excluded.'
    )
    targetedAppIds: Optional[List[str]] = Field(
        None, description='A list of application IDs to be included.'
    )


class TimeUnitType(Enum):
    TIME_UNIT_TYPE_UNSPECIFIED = 'TIME_UNIT_TYPE_UNSPECIFIED'
    MINUTE = 'MINUTE'
    HOUR = 'HOUR'
    DAY = 'DAY'
    WEEK = 'WEEK'
    MONTH = 'MONTH'
    LIFETIME = 'LIFETIME'
    POD = 'POD'
    STREAM = 'STREAM'


class FrequencyCap(BaseModel):
    maxImpressions: Optional[int] = Field(
        None,
        description='The maximum number of impressions that can be served to a user within the specified time period.',
    )
    numTimeUnits: Optional[int] = Field(
        None,
        description='The amount of time, in the units specified by time_unit_type. Defines the amount of time over which impressions per user are counted and capped.',
    )
    timeUnitType: Optional[TimeUnitType] = Field(
        None,
        description='The time unit. Along with num_time_units defines the amount of time over which impressions per user are counted and capped.',
    )


class ReservationType(Enum):
    RESERVATION_TYPE_UNSPECIFIED = 'RESERVATION_TYPE_UNSPECIFIED'
    STANDARD = 'STANDARD'
    SPONSORSHIP = 'SPONSORSHIP'


class HtmlContent(BaseModel):
    height: Optional[int] = Field(
        None, description='The height of the HTML snippet in pixels.'
    )
    snippet: Optional[str] = Field(
        None,
        description='The HTML snippet that displays the ad when inserted in the web page.',
    )
    width: Optional[int] = Field(
        None, description='The width of the HTML snippet in pixels.'
    )


class Image(BaseModel):
    height: Optional[int] = Field(None, description='Image height in pixels.')
    url: Optional[str] = Field(None, description='The URL of the image.')
    width: Optional[int] = Field(None, description='Image width in pixels.')


class InventorySizeTargeting(BaseModel):
    excludedInventorySizes: Optional[List[AdSize]] = Field(
        None, description='A list of inventory sizes to be excluded.'
    )
    targetedInventorySizes: Optional[List[AdSize]] = Field(
        None, description='A list of inventory sizes to be included.'
    )


class ListClientUserInvitationsResponse(BaseModel):
    invitations: Optional[List[ClientUserInvitation]] = Field(
        None, description='The returned list of client users.'
    )
    nextPageToken: Optional[str] = Field(
        None,
        description='A token to retrieve the next page of results. Pass this value in the ListClientUserInvitationsRequest.pageToken field in the subsequent call to the clients.invitations.list method to retrieve the next page of results.',
    )


class ListClientUsersResponse(BaseModel):
    nextPageToken: Optional[str] = Field(
        None,
        description='A token to retrieve the next page of results. Pass this value in the ListClientUsersRequest.pageToken field in the subsequent call to the clients.invitations.list method to retrieve the next page of results.',
    )
    users: Optional[List[ClientUser]] = Field(
        None, description='The returned list of client users.'
    )


class ListClientsResponse(BaseModel):
    clients: Optional[List[Client]] = Field(
        None, description='The returned list of clients.'
    )
    nextPageToken: Optional[str] = Field(
        None,
        description='A token to retrieve the next page of results. Pass this value in the ListClientsRequest.pageToken field in the subsequent call to the accounts.clients.list method to retrieve the next page of results.',
    )


class DetailType(Enum):
    DETAIL_TYPE_UNSPECIFIED = 'DETAIL_TYPE_UNSPECIFIED'
    CREATIVE_ATTRIBUTE = 'CREATIVE_ATTRIBUTE'
    VENDOR = 'VENDOR'
    SENSITIVE_CATEGORY = 'SENSITIVE_CATEGORY'
    PRODUCT_CATEGORY = 'PRODUCT_CATEGORY'
    DISAPPROVAL_REASON = 'DISAPPROVAL_REASON'
    POLICY_TOPIC = 'POLICY_TOPIC'
    ATP_VENDOR = 'ATP_VENDOR'
    VENDOR_DOMAIN = 'VENDOR_DOMAIN'
    GVL_ID = 'GVL_ID'


class ListDealAssociationsResponse(BaseModel):
    associations: Optional[List[CreativeDealAssociation]] = Field(
        None, description='The list of associations.'
    )
    nextPageToken: Optional[str] = Field(
        None,
        description="A token to retrieve the next page of results. Pass this value in the ListDealAssociationsRequest.page_token field in the subsequent call to 'ListDealAssociation' method to retrieve the next page of results.",
    )


class LocationContext(BaseModel):
    geoCriteriaIds: Optional[List[int]] = Field(
        None,
        description='IDs representing the geo location for this context. Refer to the [geo-table.csv](https://storage.googleapis.com/adx-rtb-dictionaries/geo-table.csv) file for different geo criteria IDs.',
    )


class MetricValue(BaseModel):
    value: Optional[str] = Field(None, description='The expected value of the metric.')
    variance: Optional[str] = Field(
        None,
        description='The variance (for example, square of the standard deviation) of the metric value. If value is exact, variance is 0. Can be used to calculate margin of error as a percentage of value, using the following formula, where Z is the standard constant that depends on the preferred size of the confidence interval (for example, for 90% confidence interval, use Z = 1.645): marginOfError = 100 * Z * sqrt(variance) / value',
    )


class MobileApplicationTargeting(BaseModel):
    firstPartyTargeting: Optional[FirstPartyMobileApplicationTargeting] = Field(
        None,
        description='Publisher owned apps to be targeted or excluded by the publisher to display the ads in.',
    )


class Money(BaseModel):
    currencyCode: Optional[str] = Field(
        None, description='The three-letter currency code defined in ISO 4217.'
    )
    nanos: Optional[int] = Field(
        None,
        description='Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.',
    )
    units: Optional[str] = Field(
        None,
        description='The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.',
    )


class NativeContent(BaseModel):
    advertiserName: Optional[str] = Field(
        None,
        description='The name of the advertiser or sponsor, to be displayed in the ad creative.',
    )
    appIcon: Optional[Image] = Field(
        None, description='The app icon, for app download ads.'
    )
    body: Optional[str] = Field(None, description='A long description of the ad.')
    callToAction: Optional[str] = Field(
        None, description='A label for the button that the user is supposed to click.'
    )
    clickLinkUrl: Optional[str] = Field(
        None,
        description='The URL that the browser/SDK will load when the user clicks the ad.',
    )
    clickTrackingUrl: Optional[str] = Field(
        None, description='The URL to use for click tracking.'
    )
    headline: Optional[str] = Field(None, description='A short title for the ad.')
    image: Optional[Image] = Field(None, description='A large image.')
    logo: Optional[Image] = Field(
        None, description="A smaller image, for the advertiser's logo."
    )
    priceDisplayText: Optional[str] = Field(
        None, description='The price of the promoted app including currency info.'
    )
    starRating: Optional[float] = Field(
        None, description='The app rating in the app store. Must be in the range [0-5].'
    )
    storeUrl: Optional[str] = Field(
        None,
        description='The URL to the app store to purchase/download the promoted app.',
    )
    videoUrl: Optional[str] = Field(
        None, description='The URL to fetch a native video ad.'
    )


class Status3(Enum):
    STATUS_UNSPECIFIED = 'STATUS_UNSPECIFIED'
    AD_NOT_RENDERED = 'AD_NOT_RENDERED'
    INVALID_IMPRESSION = 'INVALID_IMPRESSION'
    FATAL_VAST_ERROR = 'FATAL_VAST_ERROR'
    LOST_IN_MEDIATION = 'LOST_IN_MEDIATION'


class CreatorRole(Enum):
    BUYER_SELLER_ROLE_UNSPECIFIED = 'BUYER_SELLER_ROLE_UNSPECIFIED'
    BUYER = 'BUYER'
    SELLER = 'SELLER'


class Note(BaseModel):
    createTime: Optional[str] = Field(
        None, description='Output only. The timestamp for when this note was created.'
    )
    creatorRole: Optional[CreatorRole] = Field(
        None,
        description='Output only. The role of the person (buyer/seller) creating the note.',
    )
    note: Optional[str] = Field(
        None,
        description='The actual note to attach. (max-length: 1024 unicode code units) Note: This field may be set only when creating the resource. Modifying this field while updating the resource will result in an error.',
    )
    noteId: Optional[str] = Field(
        None, description='Output only. The unique ID for the note.'
    )
    proposalRevision: Optional[str] = Field(
        None,
        description='Output only. The revision number of the proposal when the note is created.',
    )


class OperatingSystemTargeting(BaseModel):
    operatingSystemCriteria: Optional[CriteriaTargeting] = Field(
        None, description='IDs of operating systems to be included/excluded.'
    )
    operatingSystemVersionCriteria: Optional[CriteriaTargeting] = Field(
        None, description='IDs of operating system versions to be included/excluded.'
    )


class PauseProposalDealsRequest(BaseModel):
    externalDealIds: Optional[List[str]] = Field(
        None,
        description="The external_deal_id's of the deals to be paused. If empty, all the deals in the proposal will be paused.",
    )
    reason: Optional[str] = Field(
        None,
        description="The reason why the deals are being paused. This human readable message will be displayed in the seller's UI. (Max length: 1000 unicode code units.)",
    )


class PauseProposalRequest(BaseModel):
    reason: Optional[str] = Field(
        None,
        description="The reason why the proposal is being paused. This human readable message will be displayed in the seller's UI. (Max length: 1000 unicode code units.)",
    )


class Platform1(Enum):
    DESKTOP = 'DESKTOP'
    ANDROID = 'ANDROID'
    IOS = 'IOS'


class PlatformContext(BaseModel):
    platforms: Optional[List[Platform1]] = Field(
        None, description='The platforms this restriction applies to.'
    )


class PricingType(Enum):
    PRICING_TYPE_UNSPECIFIED = 'PRICING_TYPE_UNSPECIFIED'
    COST_PER_MILLE = 'COST_PER_MILLE'
    COST_PER_DAY = 'COST_PER_DAY'


class Price(BaseModel):
    amount: Optional[Money] = Field(
        None, description='The actual price with currency specified.'
    )
    pricingType: Optional[PricingType] = Field(
        None, description='The pricing type for the deal/product. (default: CPM)'
    )


class PricePerBuyer(BaseModel):
    advertiserIds: Optional[List[str]] = Field(
        None,
        description='The list of advertisers for this price when associated with this buyer. If empty, all advertisers with this buyer pay this price.',
    )
    buyer: Optional[Buyer] = Field(
        None,
        description="The buyer who will pay this price. If unset, all buyers can pay this price (if the advertisers match, and there's no more specific rule matching the buyer).",
    )
    price: Optional[Price] = Field(None, description='The specified price.')


class PrivateData(BaseModel):
    referenceId: Optional[str] = Field(
        None,
        description='A buyer or seller specified reference ID. This can be queried in the list operations (max-length: 1024 unicode code units).',
    )


class LastUpdaterOrCommentorRole(Enum):
    BUYER_SELLER_ROLE_UNSPECIFIED = 'BUYER_SELLER_ROLE_UNSPECIFIED'
    BUYER = 'BUYER'
    SELLER = 'SELLER'


class OriginatorRole(Enum):
    BUYER_SELLER_ROLE_UNSPECIFIED = 'BUYER_SELLER_ROLE_UNSPECIFIED'
    BUYER = 'BUYER'
    SELLER = 'SELLER'


class ProposalState(Enum):
    PROPOSAL_STATE_UNSPECIFIED = 'PROPOSAL_STATE_UNSPECIFIED'
    PROPOSED = 'PROPOSED'
    BUYER_ACCEPTED = 'BUYER_ACCEPTED'
    SELLER_ACCEPTED = 'SELLER_ACCEPTED'
    CANCELED = 'CANCELED'
    FINALIZED = 'FINALIZED'


class AppStore(Enum):
    APP_STORE_TYPE_UNSPECIFIED = 'APP_STORE_TYPE_UNSPECIFIED'
    APPLE_ITUNES = 'APPLE_ITUNES'
    GOOGLE_PLAY = 'GOOGLE_PLAY'
    ROKU = 'ROKU'
    AMAZON_FIRETV = 'AMAZON_FIRETV'
    PLAYSTATION = 'PLAYSTATION'
    XBOX = 'XBOX'
    SAMSUNG_TV = 'SAMSUNG_TV'
    AMAZON = 'AMAZON'
    OPPO = 'OPPO'
    SAMSUNG = 'SAMSUNG'
    VIVO = 'VIVO'
    XIAOMI = 'XIAOMI'


class PublisherProfileMobileApplication(BaseModel):
    appStore: Optional[AppStore] = Field(
        None, description='The app store the app belongs to.'
    )
    externalAppId: Optional[str] = Field(
        None, description='The external ID for the app from its app store.'
    )
    name: Optional[str] = Field(None, description='The name of the app.')


class RealtimeTimeRange(BaseModel):
    startTimestamp: Optional[str] = Field(
        None,
        description='The start timestamp of the real-time RTB metrics aggregation.',
    )


class RelativeDateRange(BaseModel):
    durationDays: Optional[int] = Field(
        None,
        description='The number of days in the requested date range, for example, for a range spanning today: 1. For a range spanning the last 7 days: 7.',
    )
    offsetDays: Optional[int] = Field(
        None,
        description='The end date of the filter set, specified as the number of days before today, for example, for a range where the last date is today: 0.',
    )


class RemoveDealAssociationRequest(BaseModel):
    association: Optional[CreativeDealAssociation] = Field(
        None,
        description='The association between a creative and a deal that should be removed.',
    )


class ResumeProposalDealsRequest(BaseModel):
    externalDealIds: Optional[List[str]] = Field(
        None,
        description="The external_deal_id's of the deals to resume. If empty, all the deals in the proposal will be resumed.",
    )


class ResumeProposalRequest(BaseModel):
    pass


class Security(Enum):
    INSECURE = 'INSECURE'
    SSL = 'SSL'


class SecurityContext(BaseModel):
    securities: Optional[List[Security]] = Field(
        None, description='The security types in this context.'
    )


class Seller(BaseModel):
    accountId: Optional[str] = Field(
        None,
        description='The unique ID for the seller. The seller fills in this field. The seller account ID is then available to buyer in the product.',
    )
    subAccountId: Optional[str] = Field(
        None, description='Output only. Ad manager network code for the seller.'
    )


class All(Enum):
    SIMPLE_CONTEXT = 'SIMPLE_CONTEXT'


class ServingContext(BaseModel):
    all: Optional[All] = Field(None, description='Matches all contexts.')
    appType: Optional[AppContext] = Field(
        None, description='Matches impressions for a particular app type.'
    )
    auctionType: Optional[AuctionContext] = Field(
        None, description='Matches impressions for a particular auction type.'
    )
    location: Optional[LocationContext] = Field(
        None,
        description='Matches impressions coming from users *or* publishers in a specific location.',
    )
    platform: Optional[PlatformContext] = Field(
        None, description='Matches impressions coming from a particular platform.'
    )
    securityType: Optional[SecurityContext] = Field(
        None, description='Matches impressions for a particular security type.'
    )


class Status4(Enum):
    STATUS_UNSPECIFIED = 'STATUS_UNSPECIFIED'
    DISAPPROVAL = 'DISAPPROVAL'
    PENDING_REVIEW = 'PENDING_REVIEW'


class ServingRestriction(BaseModel):
    contexts: Optional[List[ServingContext]] = Field(
        None, description='The contexts for the restriction.'
    )
    disapproval: Optional[Disapproval] = Field(
        None,
        description='Disapproval bound to this restriction. Only present if status=DISAPPROVED. Can be used to filter the response of the creatives.list method.',
    )
    disapprovalReasons: Optional[List[Disapproval]] = Field(
        None,
        description='Any disapprovals bound to this restriction. Only present if status=DISAPPROVED. Can be used to filter the response of the creatives.list method. Deprecated; use disapproval field instead.',
    )
    status: Optional[Status4] = Field(
        None,
        description='The status of the creative in this context (for example, it has been explicitly disapproved or is pending review).',
    )


class Size(BaseModel):
    height: Optional[int] = Field(None, description='The height of the creative.')
    width: Optional[int] = Field(None, description='The width of the creative')


class StopWatchingCreativeRequest(BaseModel):
    pass


class TechnologyTargeting(BaseModel):
    deviceCapabilityTargeting: Optional[CriteriaTargeting] = Field(
        None, description='IDs of device capabilities to be included/excluded.'
    )
    deviceCategoryTargeting: Optional[CriteriaTargeting] = Field(
        None, description='IDs of device categories to be included/excluded.'
    )
    operatingSystemTargeting: Optional[OperatingSystemTargeting] = Field(
        None, description='Operating system related targeting information.'
    )


class TimeInterval(BaseModel):
    endTime: Optional[str] = Field(
        None,
        description='The timestamp marking the end of the range (exclusive) for which data is included.',
    )
    startTime: Optional[str] = Field(
        None,
        description='The timestamp marking the start of the range (inclusive) for which data is included.',
    )


class TimeOfDay(BaseModel):
    hours: Optional[int] = Field(
        None,
        description='Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.',
    )
    minutes: Optional[int] = Field(
        None, description='Minutes of hour of day. Must be from 0 to 59.'
    )
    nanos: Optional[int] = Field(
        None,
        description='Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.',
    )
    seconds: Optional[int] = Field(
        None,
        description='Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.',
    )


class UrlTargeting(BaseModel):
    excludedUrls: Optional[List[str]] = Field(
        None, description='A list of URLs to be excluded.'
    )
    targetedUrls: Optional[List[str]] = Field(
        None, description='A list of URLs to be included.'
    )


class VideoContent(BaseModel):
    videoUrl: Optional[str] = Field(None, description='The URL to fetch a video ad.')
    videoVastXml: Optional[str] = Field(
        None,
        description='The contents of a VAST document for a video ad. This document should conform to the VAST 2.0 or 3.0 standard.',
    )


class ExcludedPositionType(Enum):
    POSITION_TYPE_UNSPECIFIED = 'POSITION_TYPE_UNSPECIFIED'
    PREROLL = 'PREROLL'
    MIDROLL = 'MIDROLL'
    POSTROLL = 'POSTROLL'


class TargetedPositionType(Enum):
    POSITION_TYPE_UNSPECIFIED = 'POSITION_TYPE_UNSPECIFIED'
    PREROLL = 'PREROLL'
    MIDROLL = 'MIDROLL'
    POSTROLL = 'POSTROLL'


class VideoTargeting(BaseModel):
    excludedPositionTypes: Optional[List[ExcludedPositionType]] = Field(
        None,
        description='A list of video positions to be excluded. Position types can either be included or excluded (XOR).',
    )
    targetedPositionTypes: Optional[List[TargetedPositionType]] = Field(
        None,
        description='A list of video positions to be included. When the included list is present, the excluded list must be empty. When the excluded list is present, the included list must be empty.',
    )


class WatchCreativeRequest(BaseModel):
    topic: Optional[str] = Field(
        None,
        description='The Pub/Sub topic to publish notifications to. This topic must already exist and must give permission to ad-exchange-buyside-reports@google.com to write to the topic. This should be the full resource name in "projects/{project_id}/topics/{topic_id}" format.',
    )


class FieldXgafv(Enum):
    field_1 = '1'
    field_2 = '2'


class Alt(Enum):
    json = 'json'
    media = 'media'
    proto = 'proto'


class DuplicateIdMode(Enum):
    NO_DUPLICATES = 'NO_DUPLICATES'
    FORCE_ENABLE_DUPLICATE_IDS = 'FORCE_ENABLE_DUPLICATE_IDS'


class FilterSyntax(Enum):
    FILTER_SYNTAX_UNSPECIFIED = 'FILTER_SYNTAX_UNSPECIFIED'
    PQL = 'PQL'
    LIST_FILTER = 'LIST_FILTER'


class AbsoluteDateRange(BaseModel):
    endDate: Optional[Date] = Field(
        None,
        description='The end date of the range (inclusive). Must be within the 30 days leading up to current date, and must be equal to or after start_date.',
    )
    startDate: Optional[Date] = Field(
        None,
        description='The start date of the range (inclusive). Must be within the 30 days leading up to current date, and must be equal to or before end_date.',
    )


class AddDealAssociationRequest(BaseModel):
    association: Optional[CreativeDealAssociation] = Field(
        None,
        description='The association between a creative and a deal that should be added.',
    )


class AddNoteRequest(BaseModel):
    note: Optional[Note] = Field(None, description='Details of the note to add.')


class Correction(BaseModel):
    contexts: Optional[List[ServingContext]] = Field(
        None, description='The contexts for the correction.'
    )
    details: Optional[List[str]] = Field(
        None, description='Additional details about what was corrected.'
    )
    type: Optional[Type] = Field(
        None, description='The type of correction that was applied to the creative.'
    )


class Creative(BaseModel):
    accountId: Optional[str] = Field(
        None,
        description='The account that this creative belongs to. Can be used to filter the response of the creatives.list method.',
    )
    adChoicesDestinationUrl: Optional[str] = Field(
        None, description='The link to AdChoices destination page.'
    )
    adTechnologyProviders: Optional[AdTechnologyProviders] = Field(
        None, description='Output only. The detected ad technology providers.'
    )
    advertiserName: Optional[str] = Field(
        None, description='The name of the company being advertised in the creative.'
    )
    agencyId: Optional[str] = Field(
        None, description='The agency ID for this creative.'
    )
    apiUpdateTime: Optional[str] = Field(
        None,
        description='Output only. The last update timestamp of the creative through the API.',
    )
    attributes: Optional[List[Attribute]] = Field(
        None,
        description='All attributes for the ads that may be shown from this creative. Can be used to filter the response of the creatives.list method.',
    )
    clickThroughUrls: Optional[List[str]] = Field(
        None, description='The set of destination URLs for the creative.'
    )
    corrections: Optional[List[Correction]] = Field(
        None,
        description='Output only. Shows any corrections that were applied to this creative.',
    )
    creativeId: Optional[str] = Field(
        None,
        description='The buyer-defined creative ID of this creative. Can be used to filter the response of the creatives.list method.',
    )
    dealsStatus: Optional[DealsStatus] = Field(
        None,
        description="Output only. The top-level deals status of this creative. If disapproved, an entry for 'auctionType=DIRECT_DEALS' (or 'ALL') in serving_restrictions will also exist. Note that this may be nuanced with other contextual restrictions, in which case, it may be preferable to read from serving_restrictions directly. Can be used to filter the response of the creatives.list method.",
    )
    declaredClickThroughUrls: Optional[List[str]] = Field(
        None, description='The set of declared destination URLs for the creative.'
    )
    detectedAdvertiserIds: Optional[List[str]] = Field(
        None, description='Output only. Detected advertiser IDs, if any.'
    )
    detectedDomains: Optional[List[str]] = Field(
        None, description='Output only. The detected domains for this creative.'
    )
    detectedLanguages: Optional[List[str]] = Field(
        None,
        description='Output only. The detected languages for this creative. The order is arbitrary. The codes are 2 or 5 characters and are documented at https://developers.google.com/adwords/api/docs/appendix/languagecodes.',
    )
    detectedProductCategories: Optional[List[int]] = Field(
        None,
        description='Output only. Detected product categories, if any. See the ad-product-categories.txt file in the technical documentation for a list of IDs.',
    )
    detectedSensitiveCategories: Optional[List[int]] = Field(
        None,
        description='Output only. Detected sensitive categories, if any. See the ad-sensitive-categories.txt file in the technical documentation for a list of IDs. You should use these IDs along with the excluded-sensitive-category field in the bid request to filter your bids.',
    )
    html: Optional[HtmlContent] = Field(None, description='An HTML creative.')
    impressionTrackingUrls: Optional[List[str]] = Field(
        None, description='The set of URLs to be called to record an impression.'
    )
    native: Optional[NativeContent] = Field(None, description='A native creative.')
    openAuctionStatus: Optional[OpenAuctionStatus] = Field(
        None,
        description="Output only. The top-level open auction status of this creative. If disapproved, an entry for 'auctionType = OPEN_AUCTION' (or 'ALL') in serving_restrictions will also exist. Note that this may be nuanced with other contextual restrictions, in which case, it may be preferable to read from serving_restrictions directly. Can be used to filter the response of the creatives.list method.",
    )
    restrictedCategories: Optional[List[RestrictedCategory]] = Field(
        None,
        description='All restricted categories for the ads that may be shown from this creative.',
    )
    servingRestrictions: Optional[List[ServingRestriction]] = Field(
        None,
        description='Output only. The granular status of this ad in specific contexts. A context here relates to where something ultimately serves (for example, a physical location, a platform, an HTTPS versus HTTP request, or the type of auction).',
    )
    vendorIds: Optional[List[int]] = Field(
        None,
        description='All vendor IDs for the ads that may be shown from this creative. See https://storage.googleapis.com/adx-rtb-dictionaries/vendors.txt for possible values.',
    )
    version: Optional[int] = Field(
        None, description='Output only. The version of this creative.'
    )
    video: Optional[VideoContent] = Field(None, description='A video creative.')


class CreativeRestrictions(BaseModel):
    creativeFormat: Optional[CreativeFormat] = Field(
        None,
        description='The format of the environment that the creatives will be displayed in.',
    )
    creativeSpecifications: Optional[List[CreativeSpecification]] = None
    skippableAdType: Optional[SkippableAdType] = Field(
        None,
        description='Skippable video ads allow viewers to skip ads after 5 seconds.',
    )


class CreativeSize(BaseModel):
    allowedFormats: Optional[List[AllowedFormat]] = Field(
        None,
        description='What formats are allowed by the publisher. If this repeated field is empty then all formats are allowed. For example, if this field contains AllowedFormatType.AUDIO then the publisher only allows an audio ad (without any video).',
    )
    companionSizes: Optional[List[Size]] = Field(
        None,
        description='For video creatives specifies the sizes of companion ads (if present). Companion sizes may be filled in only when creative_size_type = VIDEO',
    )
    creativeSizeType: Optional[CreativeSizeType] = Field(
        None, description='The creative size type.'
    )
    nativeTemplate: Optional[NativeTemplate] = Field(
        None,
        description='Output only. The native template for this creative. It will have a value only if creative_size_type = CreativeSizeType.NATIVE.',
    )
    size: Optional[Size] = Field(
        None,
        description='For regular or video creative size type, specifies the size of the creative',
    )
    skippableAdType: Optional[SkippableAdType1] = Field(
        None,
        description='The type of skippable ad for this creative. It will have a value only if creative_size_type = CreativeSizeType.VIDEO.',
    )


class DayPart(BaseModel):
    dayOfWeek: Optional[DayOfWeek] = Field(
        None,
        description='The day of the week to target. If unspecified, applicable to all days.',
    )
    endTime: Optional[TimeOfDay] = Field(
        None,
        description='The ending time of the day for the ad to show (minute level granularity). The end time is exclusive. This field is not available for filtering in PQL queries.',
    )
    startTime: Optional[TimeOfDay] = Field(
        None,
        description='The starting time of day for the ad to show (minute level granularity). The start time is inclusive. This field is not available for filtering in PQL queries.',
    )


class DayPartTargeting(BaseModel):
    dayParts: Optional[List[DayPart]] = Field(
        None, description='A list of day part targeting criterion.'
    )
    timeZoneType: Optional[TimeZoneType] = Field(
        None, description='The timezone to use for interpreting the day part targeting.'
    )


class DeliveryControl(BaseModel):
    creativeBlockingLevel: Optional[CreativeBlockingLevel] = Field(
        None,
        description='Output only. Specified the creative blocking levels to be applied.',
    )
    deliveryRateType: Optional[DeliveryRateType] = Field(
        None,
        description='Output only. Specifies how the impression delivery will be paced.',
    )
    frequencyCaps: Optional[List[FrequencyCap]] = Field(
        None, description='Output only. Specifies any frequency caps.'
    )


class FilterSet(BaseModel):
    absoluteDateRange: Optional[AbsoluteDateRange] = Field(
        None,
        description='An absolute date range, defined by a start date and an end date. Interpreted relative to Pacific time zone.',
    )
    breakdownDimensions: Optional[List[BreakdownDimension]] = Field(
        None,
        description='The set of dimensions along which to break down the response; may be empty. If multiple dimensions are requested, the breakdown is along the Cartesian product of the requested dimensions.',
    )
    creativeId: Optional[str] = Field(
        None,
        description='The ID of the creative on which to filter; optional. This field may be set only for a filter set that accesses account-level troubleshooting data, for example, one whose name matches the `bidders/*/accounts/*/filterSets/*` pattern.',
    )
    dealId: Optional[str] = Field(
        None,
        description='The ID of the deal on which to filter; optional. This field may be set only for a filter set that accesses account-level troubleshooting data, for example, one whose name matches the `bidders/*/accounts/*/filterSets/*` pattern.',
    )
    environment: Optional[Environment] = Field(
        None, description='The environment on which to filter; optional.'
    )
    format: Optional[Format] = Field(
        None,
        description='Creative format bidded on or allowed to bid on, can be empty.',
    )
    formats: Optional[List[Format]] = Field(
        None,
        description='Creative formats bidded on or allowed to bid on, can be empty. Although this field is a list, it can only be populated with a single item. A HTTP 400 bad request error will be returned in the response if you specify multiple items.',
    )
    name: Optional[str] = Field(
        None,
        description='A user-defined name of the filter set. Filter set names must be unique globally and match one of the patterns: - `bidders/*/filterSets/*` (for accessing bidder-level troubleshooting data) - `bidders/*/accounts/*/filterSets/*` (for accessing account-level troubleshooting data) This field is required in create operations.',
    )
    platforms: Optional[List[Platform]] = Field(
        None,
        description='The list of platforms on which to filter; may be empty. The filters represented by multiple platforms are ORed together (for example, if non-empty, results must match any one of the platforms).',
    )
    publisherIdentifiers: Optional[List[str]] = Field(
        None,
        description='For Open Bidding partners only. The list of publisher identifiers on which to filter; may be empty. The filters represented by multiple publisher identifiers are ORed together.',
    )
    realtimeTimeRange: Optional[RealtimeTimeRange] = Field(
        None,
        description='An open-ended realtime time range, defined by the aggregation start timestamp.',
    )
    relativeDateRange: Optional[RelativeDateRange] = Field(
        None,
        description='A relative date range, defined by an offset from today and a duration. Interpreted relative to Pacific time zone.',
    )
    sellerNetworkIds: Optional[List[int]] = Field(
        None,
        description='For Authorized Buyers only. The list of IDs of the seller (publisher) networks on which to filter; may be empty. The filters represented by multiple seller network IDs are ORed together (for example, if non-empty, results must match any one of the publisher networks). See [seller-network-ids](https://developers.google.com/authorized-buyers/rtb/downloads/seller-network-ids) file for the set of existing seller network IDs.',
    )
    timeSeriesGranularity: Optional[TimeSeriesGranularity] = Field(
        None,
        description='The granularity of time intervals if a time series breakdown is preferred; optional.',
    )


class GuaranteedFixedPriceTerms(BaseModel):
    fixedPrices: Optional[List[PricePerBuyer]] = Field(
        None, description='Fixed price for the specified buyer.'
    )
    guaranteedImpressions: Optional[str] = Field(
        None,
        description='Guaranteed impressions as a percentage. This is the percentage of guaranteed looks that the buyer is guaranteeing to buy.',
    )
    guaranteedLooks: Optional[str] = Field(
        None,
        description='Count of guaranteed looks. Required for deal, optional for product.',
    )
    impressionCap: Optional[str] = Field(
        None,
        description='The lifetime impression cap for CPM sponsorship deals. The deal will stop serving when the cap is reached.',
    )
    minimumDailyLooks: Optional[str] = Field(
        None, description='Daily minimum looks for CPD deal types.'
    )
    percentShareOfVoice: Optional[str] = Field(
        None,
        description="For sponsorship deals, this is the percentage of the seller's eligible impressions that the deal will serve until the cap is reached.",
    )
    reservationType: Optional[ReservationType] = Field(
        None,
        description='The reservation type for a Programmatic Guaranteed deal. This indicates whether the number of impressions is fixed, or a percent of available impressions. If not specified, the default reservation type is STANDARD.',
    )


class ListCreativesResponse(BaseModel):
    creatives: Optional[List[Creative]] = Field(
        None, description='The list of creatives.'
    )
    nextPageToken: Optional[str] = Field(
        None,
        description='A token to retrieve the next page of results. Pass this value in the ListCreativesRequest.page_token field in the subsequent call to `ListCreatives` method to retrieve the next page of results.',
    )


class ListFilterSetsResponse(BaseModel):
    filterSets: Optional[List[FilterSet]] = Field(
        None, description='The filter sets belonging to the buyer.'
    )
    nextPageToken: Optional[str] = Field(
        None,
        description='A token to retrieve the next page of results. Pass this value in the ListFilterSetsRequest.pageToken field in the subsequent call to the accounts.filterSets.list method to retrieve the next page of results.',
    )


class NonGuaranteedAuctionTerms(BaseModel):
    autoOptimizePrivateAuction: Optional[bool] = Field(
        None,
        description='True if open auction buyers are allowed to compete with invited buyers in this private auction.',
    )
    reservePricesPerBuyer: Optional[List[PricePerBuyer]] = Field(
        None, description='Reserve price for the specified buyer.'
    )


class NonGuaranteedFixedPriceTerms(BaseModel):
    fixedPrices: Optional[List[PricePerBuyer]] = Field(
        None, description='Fixed price for the specified buyer.'
    )


class PlacementTargeting(BaseModel):
    mobileApplicationTargeting: Optional[MobileApplicationTargeting] = Field(
        None,
        description="Mobile application targeting information in a deal. This doesn't apply to Auction Packages.",
    )
    urlTargeting: Optional[UrlTargeting] = Field(
        None, description='URLs to be included/excluded.'
    )


class PublisherProfile(BaseModel):
    audienceDescription: Optional[str] = Field(
        None, description="Description on the publisher's audience."
    )
    buyerPitchStatement: Optional[str] = Field(
        None,
        description="Statement explaining what's unique about publisher's business, and why buyers should partner with the publisher.",
    )
    directDealsContact: Optional[str] = Field(
        None,
        description='Contact information for direct reservation deals. This is free text entered by the publisher and may include information like names, phone numbers and email addresses.',
    )
    displayName: Optional[str] = Field(
        None, description='Name of the publisher profile.'
    )
    domains: Optional[List[str]] = Field(
        None,
        description='The list of domains represented in this publisher profile. Empty if this is a parent profile. These are top private domains, meaning that these will not contain a string like "photos.google.co.uk/123", but will instead contain "google.co.uk".',
    )
    googlePlusUrl: Optional[str] = Field(
        None, description="URL to publisher's Google+ page."
    )
    isParent: Optional[bool] = Field(
        None,
        description='Indicates if this profile is the parent profile of the seller. A parent profile represents all the inventory from the seller, as opposed to child profile that is created to brand a portion of inventory. One seller should have only one parent publisher profile, and can have multiple child profiles. Publisher profiles for the same seller will have same value of field google.ads.adexchange.buyer.v2beta1.PublisherProfile.seller. See https://support.google.com/admanager/answer/6035806 for details.',
    )
    logoUrl: Optional[str] = Field(
        None,
        description='A Google public URL to the logo for this publisher profile. The logo is stored as a PNG, JPG, or GIF image.',
    )
    mediaKitUrl: Optional[str] = Field(
        None, description='URL to additional marketing and sales materials.'
    )
    mobileApps: Optional[List[PublisherProfileMobileApplication]] = Field(
        None,
        description='The list of apps represented in this publisher profile. Empty if this is a parent profile.',
    )
    overview: Optional[str] = Field(None, description='Overview of the publisher.')
    programmaticDealsContact: Optional[str] = Field(
        None,
        description='Contact information for programmatic deals. This is free text entered by the publisher and may include information like names, phone numbers and email addresses.',
    )
    publisherProfileId: Optional[str] = Field(
        None, description='Unique ID for publisher profile.'
    )
    rateCardInfoUrl: Optional[str] = Field(
        None, description='URL to a publisher rate card.'
    )
    samplePageUrl: Optional[str] = Field(
        None, description='URL to a sample content page.'
    )
    seller: Optional[Seller] = Field(
        None, description='Seller of the publisher profile.'
    )
    topHeadlines: Optional[List[str]] = Field(
        None,
        description='Up to three key metrics and rankings. Max 100 characters each. For example "#1 Mobile News Site for 20 Straight Months".',
    )


class RowDimensions(BaseModel):
    publisherIdentifier: Optional[str] = Field(
        None,
        description='The publisher identifier for this row, if a breakdown by [BreakdownDimension.PUBLISHER_IDENTIFIER](https://developers.google.com/authorized-buyers/apis/reference/rest/v2beta1/bidders.accounts.filterSets#FilterSet.BreakdownDimension) was requested.',
    )
    timeInterval: Optional[TimeInterval] = Field(
        None, description='The time interval that this row represents.'
    )


class TargetingValue(BaseModel):
    creativeSizeValue: Optional[CreativeSize] = Field(
        None,
        description='The creative size value to include/exclude. Filled in when key = GOOG_CREATIVE_SIZE',
    )
    dayPartTargetingValue: Optional[DayPartTargeting] = Field(
        None,
        description='The daypart targeting to include / exclude. Filled in when the key is GOOG_DAYPART_TARGETING. The definition of this targeting is derived from the structure used by Ad Manager.',
    )
    longValue: Optional[str] = Field(
        None, description='The long value to include/exclude.'
    )
    stringValue: Optional[str] = Field(
        None, description='The string value to include/exclude.'
    )


class BidMetricsRow(BaseModel):
    bids: Optional[MetricValue] = Field(
        None, description='The number of bids that Ad Exchange received from the buyer.'
    )
    bidsInAuction: Optional[MetricValue] = Field(
        None,
        description='The number of bids that were permitted to compete in the auction.',
    )
    billedImpressions: Optional[MetricValue] = Field(
        None,
        description='The number of bids for which the buyer was billed. Also called valid impressions as invalid impressions are not billed.',
    )
    impressionsWon: Optional[MetricValue] = Field(
        None, description='The number of bids that won the auction.'
    )
    measurableImpressions: Optional[MetricValue] = Field(
        None,
        description='The number of bids for which the corresponding impression was measurable for viewability (as defined by Active View).',
    )
    reachedQueries: Optional[MetricValue] = Field(
        None,
        description='The number of bids that won the auction and also won the mediation waterfall (if any).',
    )
    rowDimensions: Optional[RowDimensions] = Field(
        None,
        description='The values of all dimensions associated with metric values in this row.',
    )
    viewableImpressions: Optional[MetricValue] = Field(
        None,
        description='The number of bids for which the corresponding impression was viewable (as defined by Active View).',
    )


class BidResponseWithoutBidsStatusRow(BaseModel):
    impressionCount: Optional[MetricValue] = Field(
        None,
        description='The number of impressions for which there was a bid response with the specified status.',
    )
    rowDimensions: Optional[RowDimensions] = Field(
        None,
        description='The values of all dimensions associated with metric values in this row.',
    )
    status: Optional[Status] = Field(
        None,
        description='The status specifying why the bid responses were considered to have no applicable bids.',
    )


class CalloutStatusRow(BaseModel):
    calloutStatusId: Optional[int] = Field(
        None,
        description='The ID of the callout status. See [callout-status-codes](https://developers.google.com/authorized-buyers/rtb/downloads/callout-status-codes).',
    )
    impressionCount: Optional[MetricValue] = Field(
        None,
        description='The number of impressions for which there was a bid request or bid response with the specified callout status.',
    )
    rowDimensions: Optional[RowDimensions] = Field(
        None,
        description='The values of all dimensions associated with metric values in this row.',
    )


class CreativeStatusRow(BaseModel):
    bidCount: Optional[MetricValue] = Field(
        None, description='The number of bids with the specified status.'
    )
    creativeStatusId: Optional[int] = Field(
        None,
        description='The ID of the creative status. See [creative-status-codes](https://developers.google.com/authorized-buyers/rtb/downloads/creative-status-codes).',
    )
    rowDimensions: Optional[RowDimensions] = Field(
        None,
        description='The values of all dimensions associated with metric values in this row.',
    )


class DealTerms(BaseModel):
    brandingType: Optional[BrandingType] = Field(
        None, description='Visibility of the URL in bid requests. (default: BRANDED)'
    )
    description: Optional[str] = Field(
        None, description='Publisher provided description for the terms.'
    )
    estimatedGrossSpend: Optional[Price] = Field(
        None,
        description='Non-binding estimate of the estimated gross spend for this deal. Can be set by buyer or seller.',
    )
    estimatedImpressionsPerDay: Optional[str] = Field(
        None,
        description='Non-binding estimate of the impressions served per day. Can be set by buyer or seller.',
    )
    guaranteedFixedPriceTerms: Optional[GuaranteedFixedPriceTerms] = Field(
        None, description='The terms for guaranteed fixed price deals.'
    )
    nonGuaranteedAuctionTerms: Optional[NonGuaranteedAuctionTerms] = Field(
        None, description='The terms for non-guaranteed auction deals.'
    )
    nonGuaranteedFixedPriceTerms: Optional[NonGuaranteedFixedPriceTerms] = Field(
        None, description='The terms for non-guaranteed fixed price deals.'
    )
    sellerTimeZone: Optional[str] = Field(
        None,
        description='The time zone name. For deals with Cost Per Day billing, defines the time zone used to mark the boundaries of a day. It should be an IANA TZ name, such as "America/Los_Angeles". For more information, see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.',
    )


class FilteredBidCreativeRow(BaseModel):
    bidCount: Optional[MetricValue] = Field(
        None, description='The number of bids with the specified creative.'
    )
    creativeId: Optional[str] = Field(None, description='The ID of the creative.')
    rowDimensions: Optional[RowDimensions] = Field(
        None,
        description='The values of all dimensions associated with metric values in this row.',
    )


class FilteredBidDetailRow(BaseModel):
    bidCount: Optional[MetricValue] = Field(
        None, description='The number of bids with the specified detail.'
    )
    detail: Optional[str] = Field(
        None,
        description='The ID of the detail, can be numeric or text. The associated value can be looked up in the dictionary file corresponding to the DetailType in the response message.',
    )
    detailId: Optional[int] = Field(
        None,
        description='Note: this field will be deprecated, use "detail" field instead. When "detail" field represents an integer value, this field is populated as the same integer value "detail" field represents, otherwise this field will be 0. The ID of the detail. The associated value can be looked up in the dictionary file corresponding to the DetailType in the response message.',
    )
    rowDimensions: Optional[RowDimensions] = Field(
        None,
        description='The values of all dimensions associated with metric values in this row.',
    )


class ImpressionMetricsRow(BaseModel):
    availableImpressions: Optional[MetricValue] = Field(
        None,
        description='The number of impressions available to the buyer on Ad Exchange. In some cases this value may be unavailable.',
    )
    bidRequests: Optional[MetricValue] = Field(
        None,
        description='The number of impressions for which Ad Exchange sent the buyer a bid request.',
    )
    inventoryMatches: Optional[MetricValue] = Field(
        None,
        description="The number of impressions that match the buyer's inventory pretargeting.",
    )
    responsesWithBids: Optional[MetricValue] = Field(
        None,
        description='The number of impressions for which Ad Exchange received a response from the buyer that contained at least one applicable bid.',
    )
    rowDimensions: Optional[RowDimensions] = Field(
        None,
        description='The values of all dimensions associated with metric values in this row.',
    )
    successfulResponses: Optional[MetricValue] = Field(
        None,
        description='The number of impressions for which the buyer successfully sent a response to Ad Exchange.',
    )


class ListBidMetricsResponse(BaseModel):
    bidMetricsRows: Optional[List[BidMetricsRow]] = Field(
        None, description='List of rows, each containing a set of bid metrics.'
    )
    nextPageToken: Optional[str] = Field(
        None,
        description='A token to retrieve the next page of results. Pass this value in the ListBidMetricsRequest.pageToken field in the subsequent call to the bidMetrics.list method to retrieve the next page of results.',
    )


class ListBidResponseErrorsResponse(BaseModel):
    calloutStatusRows: Optional[List[CalloutStatusRow]] = Field(
        None,
        description='List of rows, with counts of bid responses aggregated by callout status.',
    )
    nextPageToken: Optional[str] = Field(
        None,
        description='A token to retrieve the next page of results. Pass this value in the ListBidResponseErrorsRequest.pageToken field in the subsequent call to the bidResponseErrors.list method to retrieve the next page of results.',
    )


class ListBidResponsesWithoutBidsResponse(BaseModel):
    bidResponseWithoutBidsStatusRows: Optional[
        List[BidResponseWithoutBidsStatusRow]
    ] = Field(
        None,
        description='List of rows, with counts of bid responses without bids aggregated by status.',
    )
    nextPageToken: Optional[str] = Field(
        None,
        description='A token to retrieve the next page of results. Pass this value in the ListBidResponsesWithoutBidsRequest.pageToken field in the subsequent call to the bidResponsesWithoutBids.list method to retrieve the next page of results.',
    )


class ListCreativeStatusBreakdownByCreativeResponse(BaseModel):
    filteredBidCreativeRows: Optional[List[FilteredBidCreativeRow]] = Field(
        None,
        description='List of rows, with counts of bids with a given creative status aggregated by creative.',
    )
    nextPageToken: Optional[str] = Field(
        None,
        description='A token to retrieve the next page of results. Pass this value in the ListCreativeStatusBreakdownByCreativeRequest.pageToken field in the subsequent call to the filteredBids.creatives.list method to retrieve the next page of results.',
    )


class ListCreativeStatusBreakdownByDetailResponse(BaseModel):
    detailType: Optional[DetailType] = Field(
        None, description='The type of detail that the detail IDs represent.'
    )
    filteredBidDetailRows: Optional[List[FilteredBidDetailRow]] = Field(
        None,
        description='List of rows, with counts of bids with a given creative status aggregated by detail.',
    )
    nextPageToken: Optional[str] = Field(
        None,
        description='A token to retrieve the next page of results. Pass this value in the ListCreativeStatusBreakdownByDetailRequest.pageToken field in the subsequent call to the filteredBids.details.list method to retrieve the next page of results.',
    )


class ListFilteredBidRequestsResponse(BaseModel):
    calloutStatusRows: Optional[List[CalloutStatusRow]] = Field(
        None,
        description='List of rows, with counts of filtered bid requests aggregated by callout status.',
    )
    nextPageToken: Optional[str] = Field(
        None,
        description='A token to retrieve the next page of results. Pass this value in the ListFilteredBidRequestsRequest.pageToken field in the subsequent call to the filteredBidRequests.list method to retrieve the next page of results.',
    )


class ListFilteredBidsResponse(BaseModel):
    creativeStatusRows: Optional[List[CreativeStatusRow]] = Field(
        None,
        description='List of rows, with counts of filtered bids aggregated by filtering reason (for example, creative status).',
    )
    nextPageToken: Optional[str] = Field(
        None,
        description='A token to retrieve the next page of results. Pass this value in the ListFilteredBidsRequest.pageToken field in the subsequent call to the filteredBids.list method to retrieve the next page of results.',
    )


class ListImpressionMetricsResponse(BaseModel):
    impressionMetricsRows: Optional[List[ImpressionMetricsRow]] = Field(
        None, description='List of rows, each containing a set of impression metrics.'
    )
    nextPageToken: Optional[str] = Field(
        None,
        description='A token to retrieve the next page of results. Pass this value in the ListImpressionMetricsRequest.pageToken field in the subsequent call to the impressionMetrics.list method to retrieve the next page of results.',
    )


class ListLosingBidsResponse(BaseModel):
    creativeStatusRows: Optional[List[CreativeStatusRow]] = Field(
        None,
        description='List of rows, with counts of losing bids aggregated by loss reason (for example, creative status).',
    )
    nextPageToken: Optional[str] = Field(
        None,
        description='A token to retrieve the next page of results. Pass this value in the ListLosingBidsRequest.pageToken field in the subsequent call to the losingBids.list method to retrieve the next page of results.',
    )


class ListPublisherProfilesResponse(BaseModel):
    nextPageToken: Optional[str] = Field(None, description='List pagination support')
    publisherProfiles: Optional[List[PublisherProfile]] = Field(
        None, description='The list of matching publisher profiles.'
    )


class MarketplaceTargeting(BaseModel):
    geoTargeting: Optional[CriteriaTargeting] = Field(
        None, description='Geo criteria IDs to be included/excluded.'
    )
    inventorySizeTargeting: Optional[InventorySizeTargeting] = Field(
        None, description='Inventory sizes to be included/excluded.'
    )
    placementTargeting: Optional[PlacementTargeting] = Field(
        None,
        description='Placement targeting information, for example, URL, mobile applications.',
    )
    technologyTargeting: Optional[TechnologyTargeting] = Field(
        None,
        description='Technology targeting information, for example, operating system, device category.',
    )
    videoTargeting: Optional[VideoTargeting] = Field(
        None, description='Video targeting information.'
    )


class NonBillableWinningBidStatusRow(BaseModel):
    bidCount: Optional[MetricValue] = Field(
        None, description='The number of bids with the specified status.'
    )
    rowDimensions: Optional[RowDimensions] = Field(
        None,
        description='The values of all dimensions associated with metric values in this row.',
    )
    status: Optional[Status3] = Field(
        None, description='The status specifying why the winning bids were not billed.'
    )


class TargetingCriteria(BaseModel):
    exclusions: Optional[List[TargetingValue]] = Field(
        None,
        description="The list of values to exclude from targeting. Each value is AND'd together.",
    )
    inclusions: Optional[List[TargetingValue]] = Field(
        None,
        description="The list of value to include as part of the targeting. Each value is OR'd together.",
    )
    key: Optional[str] = Field(
        None,
        description='The key representing the shared targeting criterion. Targeting criteria defined by Google ad servers will begin with GOOG_. Third parties may define their own keys. A list of permissible keys along with the acceptable values will be provided as part of the external documentation.',
    )


class Deal(BaseModel):
    availableEndTime: Optional[str] = Field(
        None,
        description='Proposed flight end time of the deal. This will generally be stored in a granularity of a second. A value is not required for Private Auction deals or Preferred Deals.',
    )
    availableStartTime: Optional[str] = Field(
        None,
        description='Optional. Proposed flight start time of the deal. This will generally be stored in the granularity of one second since deal serving starts at seconds boundary. Any time specified with more granularity (for example, in milliseconds) will be truncated towards the start of time in seconds.',
    )
    buyerPrivateData: Optional[PrivateData] = Field(
        None, description='Buyer private data (hidden from seller).'
    )
    createProductId: Optional[str] = Field(
        None,
        description='The product ID from which this deal was created. Note: This field may be set only when creating the resource. Modifying this field while updating the resource will result in an error.',
    )
    createProductRevision: Optional[str] = Field(
        None,
        description='Optional. Revision number of the product that the deal was created from. If present on create, and the server `product_revision` has advanced since the passed-in `create_product_revision`, an `ABORTED` error will be returned. Note: This field may be set only when creating the resource. Modifying this field while updating the resource will result in an error.',
    )
    createTime: Optional[str] = Field(
        None, description='Output only. The time of the deal creation.'
    )
    creativePreApprovalPolicy: Optional[CreativePreApprovalPolicy] = Field(
        None, description='Output only. Specifies the creative pre-approval policy.'
    )
    creativeRestrictions: Optional[CreativeRestrictions] = Field(
        None,
        description='Output only. Restricitions about the creatives associated with the deal (for example, size) This is available for Programmatic Guaranteed/Preferred Deals in Ad Manager.',
    )
    creativeSafeFrameCompatibility: Optional[CreativeSafeFrameCompatibility] = Field(
        None,
        description='Output only. Specifies whether the creative is safeFrame compatible.',
    )
    dealId: Optional[str] = Field(
        None,
        description='Output only. A unique deal ID for the deal (server-assigned).',
    )
    dealServingMetadata: Optional[DealServingMetadata] = Field(
        None, description='Output only. Metadata about the serving status of this deal.'
    )
    dealTerms: Optional[DealTerms] = Field(
        None, description='The negotiable terms of the deal.'
    )
    deliveryControl: Optional[DeliveryControl] = Field(
        None,
        description='The set of fields around delivery control that are interesting for a buyer to see but are non-negotiable. These are set by the publisher.',
    )
    description: Optional[str] = Field(
        None, description='Description for the deal terms.'
    )
    displayName: Optional[str] = Field(None, description='The name of the deal.')
    externalDealId: Optional[str] = Field(
        None,
        description='Output only. The external deal ID assigned to this deal once the deal is finalized. This is the deal ID that shows up in serving/reporting etc.',
    )
    isSetupComplete: Optional[bool] = Field(
        None,
        description='Output only. True, if the buyside inventory setup is complete for this deal.',
    )
    programmaticCreativeSource: Optional[ProgrammaticCreativeSource] = Field(
        None,
        description='Output only. Specifies the creative source for programmatic deals. PUBLISHER means creative is provided by seller and ADVERTISER means creative is provided by buyer.',
    )
    proposalId: Optional[str] = Field(
        None, description='Output only. ID of the proposal that this deal is part of.'
    )
    sellerContacts: Optional[List[ContactInformation]] = Field(
        None, description='Output only. Seller contact information for the deal.'
    )
    syndicationProduct: Optional[SyndicationProduct] = Field(
        None,
        description='The syndication product associated with the deal. Note: This field may be set only when creating the resource. Modifying this field while updating the resource will result in an error.',
    )
    targeting: Optional[MarketplaceTargeting] = Field(
        None,
        description='Output only. Specifies the subset of inventory targeted by the deal.',
    )
    targetingCriterion: Optional[List[TargetingCriteria]] = Field(
        None,
        description="The shared targeting visible to buyers and sellers. Each shared targeting entity is AND'd together.",
    )
    updateTime: Optional[str] = Field(
        None, description='Output only. The time when the deal was last updated.'
    )
    webPropertyCode: Optional[str] = Field(
        None,
        description='The web property code for the seller copied over from the product.',
    )


class ListNonBillableWinningBidsResponse(BaseModel):
    nextPageToken: Optional[str] = Field(
        None,
        description='A token to retrieve the next page of results. Pass this value in the ListNonBillableWinningBidsRequest.pageToken field in the subsequent call to the nonBillableWinningBids.list method to retrieve the next page of results.',
    )
    nonBillableWinningBidStatusRows: Optional[List[NonBillableWinningBidStatusRow]] = (
        Field(
            None,
            description='List of rows, with counts of bids not billed aggregated by reason.',
        )
    )


class Product(BaseModel):
    availableEndTime: Optional[str] = Field(
        None,
        description='The proposed end time for the deal. The field will be truncated to the order of seconds during serving.',
    )
    availableStartTime: Optional[str] = Field(
        None,
        description='Inventory availability dates. The start time will be truncated to seconds during serving. Thus, a field specified as 3:23:34.456 (HH:mm:ss.SSS) will be truncated to 3:23:34 when serving.',
    )
    createTime: Optional[str] = Field(None, description='Creation time.')
    creatorContacts: Optional[List[ContactInformation]] = Field(
        None,
        description='Optional contact information for the creator of this product.',
    )
    displayName: Optional[str] = Field(
        None, description='The display name for this product as set by the seller.'
    )
    hasCreatorSignedOff: Optional[bool] = Field(
        None,
        description='If the creator has already signed off on the product, then the buyer can finalize the deal by accepting the product as is. When copying to a proposal, if any of the terms are changed, then auto_finalize is automatically set to false.',
    )
    productId: Optional[str] = Field(None, description='The unique ID for the product.')
    productRevision: Optional[str] = Field(
        None,
        description='The revision number of the product (auto-assigned by Marketplace).',
    )
    publisherProfileId: Optional[str] = Field(
        None,
        description='An ID which can be used by the Publisher Profile API to get more information about the seller that created this product.',
    )
    seller: Optional[Seller] = Field(
        None, description='Information about the seller that created this product.'
    )
    syndicationProduct: Optional[SyndicationProduct] = Field(
        None, description='The syndication product associated with the deal.'
    )
    targetingCriterion: Optional[List[TargetingCriteria]] = Field(
        None,
        description='Targeting that is shared between the buyer and the seller. Each targeting criterion has a specified key and for each key there is a list of inclusion value or exclusion values.',
    )
    terms: Optional[DealTerms] = Field(
        None, description='The negotiable terms of the deal.'
    )
    updateTime: Optional[str] = Field(None, description='Time of last update.')
    webPropertyCode: Optional[str] = Field(
        None,
        description='The web-property code for the seller. This needs to be copied as is when adding a new deal to a proposal.',
    )


class Proposal(BaseModel):
    billedBuyer: Optional[Buyer] = Field(
        None,
        description='Output only. Reference to the buyer that will get billed for this proposal.',
    )
    buyer: Optional[Buyer] = Field(
        None,
        description='Reference to the buyer on the proposal. Note: This field may be set only when creating the resource. Modifying this field while updating the resource will result in an error.',
    )
    buyerContacts: Optional[List[ContactInformation]] = Field(
        None, description='Contact information for the buyer.'
    )
    buyerPrivateData: Optional[PrivateData] = Field(
        None, description='Private data for buyer. (hidden from seller).'
    )
    deals: Optional[List[Deal]] = Field(
        None,
        description='The deals associated with this proposal. For Private Auction proposals (whose deals have NonGuaranteedAuctionTerms), there will only be one deal.',
    )
    displayName: Optional[str] = Field(None, description='The name for the proposal.')
    isRenegotiating: Optional[bool] = Field(
        None, description='Output only. True if the proposal is being renegotiated.'
    )
    isSetupComplete: Optional[bool] = Field(
        None,
        description='Output only. True, if the buyside inventory setup is complete for this proposal.',
    )
    lastUpdaterOrCommentorRole: Optional[LastUpdaterOrCommentorRole] = Field(
        None,
        description='Output only. The role of the last user that either updated the proposal or left a comment.',
    )
    notes: Optional[List[Note]] = Field(
        None, description='Output only. The notes associated with this proposal.'
    )
    originatorRole: Optional[OriginatorRole] = Field(
        None,
        description='Output only. Indicates whether the buyer/seller created the proposal.',
    )
    privateAuctionId: Optional[str] = Field(
        None,
        description='Output only. Private auction ID if this proposal is a private auction proposal.',
    )
    proposalId: Optional[str] = Field(
        None, description='Output only. The unique ID of the proposal.'
    )
    proposalRevision: Optional[str] = Field(
        None,
        description='Output only. The revision number for the proposal. Each update to the proposal or the deal causes the proposal revision number to auto-increment. The buyer keeps track of the last revision number they know of and pass it in when making an update. If the head revision number on the server has since incremented, then an ABORTED error is returned during the update operation to let the buyer know that a subsequent update was made.',
    )
    proposalState: Optional[ProposalState] = Field(
        None, description='Output only. The current state of the proposal.'
    )
    seller: Optional[Seller] = Field(
        None,
        description='Reference to the seller on the proposal. Note: This field may be set only when creating the resource. Modifying this field while updating the resource will result in an error.',
    )
    sellerContacts: Optional[List[ContactInformation]] = Field(
        None, description='Output only. Contact information for the seller.'
    )
    termsAndConditions: Optional[str] = Field(
        None,
        description='Output only. The terms and conditions set by the publisher for this proposal.',
    )
    updateTime: Optional[str] = Field(
        None, description='Output only. The time when the proposal was last revised.'
    )


class ListProductsResponse(BaseModel):
    nextPageToken: Optional[str] = Field(None, description='List pagination support.')
    products: Optional[List[Product]] = Field(
        None, description='The list of matching products at their head revision number.'
    )


class ListProposalsResponse(BaseModel):
    nextPageToken: Optional[str] = Field(
        None, description='Continuation token for fetching the next page of results.'
    )
    proposals: Optional[List[Proposal]] = Field(
        None, description='The list of proposals.'
    )
